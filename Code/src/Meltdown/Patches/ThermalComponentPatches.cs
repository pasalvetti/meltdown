using HarmonyLib;
using KSP;
using KSP.Logging;
using KSP.Sim;
using KSP.Sim.impl;
using KSP.Sim.Util;
using Meltdown.Modules;

namespace Meltdown.Patches
{
    internal class ThermalComponentPatches
    {
        /**
         * Add all radiator parts in the list of coolers. They will be taken into account later on (in OnUpdate) for the dissipation.
         **/
        private static void CacheAllRadiatorsAsCoolingModules(ThermalComponent __instance)
        {
            foreach (PartComponent part in __instance.SimulationObject.PartOwner.Parts)
            {
                if (part.TryGetModule<PartComponentModule_ActiveRadiator>(out PartComponentModule_ActiveRadiator module))
                {
                    __instance._coolingModules.AddUnique<PartComponentModule_Cooler>(module);
                }
            }
        }

        /**
         * On component start, all cooling modules get cached, but not radiators. We need to add them too.
         **/
        [HarmonyPatch(typeof(ThermalComponent), nameof(ThermalComponent.OnStart))]
        [HarmonyPostfix]
        public static void OnStartPostFix(ThermalComponent __instance)
        {
            CacheAllRadiatorsAsCoolingModules(__instance);
        }

        /**
         * After a part is destroyed, RecacheCoolingModules gets called and clears our list of radiators, so we need to recache them.
         **/
        [HarmonyPatch(typeof(ThermalComponent), nameof(ThermalComponent.RecacheCoolingModules))]
        [HarmonyPostfix]
        private static void RecacheCoolingModulesPostFix(ThermalComponent __instance)
        {
            CacheAllRadiatorsAsCoolingModules(__instance);
        }

        /**
         * Return true if the part is generating heat.
         **/
        private static bool IsGeneretingHeat(PartComponent part)
        {
            if (part.TryGetModule<PartComponentModule_Thermal>(out PartComponentModule_Thermal thermalModule))
            {
                if (thermalModule._dataThermal == null) return false;
                return thermalModule._dataThermal.isHeating;
            }
            return false;
        }

        /**
         * Returns the thermal energy applied to a part.
         **/
        private static double getTotalThermalEnergyOfPart(PartComponent part)
        {
            return part.ThermalData.OtherFlux + part.ThermalData.EnvironmentFlux + part.ThermalData.ExhaustFlux + part.ThermalData.ReentryFlux + part.ThermalData.SolarFlux;
        }

        /**
         * Returns the sum of thermal energy applied to each part of the current vessel.
         **/
        private static double GetTotalThermalEnergy(ThermalComponent __instance)
        {
            double totalThermalEnergy = 0.0;
            foreach (PartComponent part in __instance.SimulationObject.PartOwner.Parts)
            {
                if (part.ThermalData.Equals(null)) continue;
                if (IsGeneretingHeat(part))
                {
                    totalThermalEnergy += (getTotalThermalEnergyOfPart(part));
                }
            }
            return totalThermalEnergy;
        }

        /**
         * The heat removing code is originally done by ThermalComponentJob.FinalizeJob but it is buggy and the way it is designed is not well balanced with the rest of the system.
         * The hack is to override this method with a prefix to prevent CoolingEnergyToApply from being valued, and to alter the OtherFlux to take into account the heat removed by the radiators.
         * This flux should normally only contain the heat generated by the part.
         * 
         * Removes from each part of the ship the energy diffused by each radiator.
         * x100 to counteract PartComponentModule_Cooler.EnergyApplied that cannot be patched and applies a x0.01 for some reasons.
         * 
         * Prefix because it needs to run before the thermal jobs.
         **/
        [HarmonyPatch(typeof(ThermalComponent), nameof(ThermalComponent.OnUpdate))]
        [HarmonyPrefix]
        public static bool OnUpdatePreFix(double universalTime, double deltaUniversalTime, ThermalComponent __instance, ref double __state)
        {
            // --- new code
            int numberOfRadiators = __instance._coolingModules.Count;
            double totalThermalEnergy = GetTotalThermalEnergy(__instance);
            __state = totalThermalEnergy;
            if (totalThermalEnergy == 0.0) return true; // if no part is generating heat, there's no heat to dissipate
            foreach (PartComponent part in __instance.SimulationObject.PartOwner.Parts)
            {
                int i = numberOfRadiators;
                double energyRemoved = 0.0;
                if (IsGeneretingHeat(part))  // if the current part is generating heat, there *is* heat to dissipate.
                {
                    while (i-- > 0)
                    {
                        if (!__instance._coolingModules[i].CoolerOperational) continue; // if the radiator is retracted, move on to the next one
                        energyRemoved += (__instance._coolingModules[i].EnergyApplied * 100 * getTotalThermalEnergyOfPart(part) / totalThermalEnergy);
                    }
                }
                if (part.TryGetModule<PartComponentModule_Thermal>(out PartComponentModule_Thermal thermalModule) && thermalModule._dataThermal != null)
                {
                    thermalModule._dataThermal.energyRemoved = energyRemoved; // we store the removed energy for display on the debug window
                }
                part.ThermalData.OtherFlux -= energyRemoved; // we substract the removed energy in the other flux (dirty hack)
            }
            // --- modified stock code
            if (__instance.Game.CheatSystem.GetDisableThermodynamics() || !__instance.Game.SessionManager.IsDifficultyOptionEnabled("HeatEnabled") || __instance.SimulationObject.IsDestroyedOrBeingDestroyed)
            {
                __instance._simulationJobInstance.CompleteJobs();
                __instance.Dispose(false);
            }
            else
            {
                if (!__instance._simulationJobInstance.IsJobComplete)
                    return false;
                if (__instance._lastJobTime == 0.0)
                {
                    __instance._deltaUniverseTime = deltaUniversalTime;
                    __instance._lastJobTime = universalTime;
                }
                else
                {
                    __instance._deltaUniverseTime = universalTime - __instance._lastJobTime;
                    __instance._lastJobTime = universalTime;
                }
                if (__instance._deltaUniverseTime <= 0.0)
                    return false;
                __instance._simulationJobInstance.CompleteJobs();
                if (__instance._simulationJobInstance.JobPartData.IsCreated)
                {
                    __instance._partsToDestroy.Clear();
                    for (int index = 0; index < __instance._simulationJobInstance.JobPartData.Length; ++index)
                    {
                        PartComponent part;
                        if (__instance.SimulationObject.PartOwner.TryGetPart(new IGGuid(ThermalComponentJob.ConvertFixedBytes16ToGuid(__instance._simulationJobInstance.JobPartData[index].Guid)), out part))
                        {
                            ThermalData thermalData1 = __instance._simulationJobInstance.JobPartData[index];
                            if (__instance._simulationJobInstance.JobPartData[index].DestroyPart)
                            {
                                __instance._partsToDestroy.Add(part);
                            }
                            else
                            {
                                ThermalData thermalData2 = part.ThermalData with
                                {
                                    ReentryFlux = thermalData1.ReentryFlux,
                                    BodyAtmosphereFlux = thermalData1.BodyAtmosphereFlux,
                                    BodyLocalFlux = thermalData1.BodyLocalFlux,
                                    BodySurfaceFlux = thermalData1.BodySurfaceFlux,
                                    EnvironmentFlux = thermalData1.EnvironmentFlux
                                };
                                part.ThermalData = thermalData2;
                                part.Temperature = thermalData1.Temperature;
                            }
                        }
                    }
                    int count = __instance._partsToDestroy.Count;
                    while (count-- > 0)
                    {
                        GlobalLog.LogF(LogFilter.Physics, "<color=red>Rigidbody {0} was destroyed due to overheating. Part Temp {1}. ReEntry Flux {2}. AtmosphereFlux {3}. Local Flux {4}. Surface Flux {5}. Environment Flux {6}.</color>", (object)__instance._partsToDestroy[count].Name, (object)__instance._partsToDestroy[count].Temperature, (object)__instance._partsToDestroy[count].ThermalData.ReentryFlux, (object)__instance._partsToDestroy[count].ThermalData.BodyAtmosphereFlux, (object)__instance._partsToDestroy[count].ThermalData.BodyLocalFlux, (object)__instance._partsToDestroy[count].ThermalData.BodySurfaceFlux, (object)__instance._partsToDestroy[count].ThermalData.EnvironmentFlux);
                        __instance._partsToDestroy[count].DestroyPart(ExplosionType.OnOverheat);
                    }
                }
                if (__instance.SimulationObject.PartOwner == null || __instance.SimulationObject.Vessel == null || __instance.SimulationObject.Vessel.mainBody == null)
                    return false;
                foreach (PartComponent part in __instance.SimulationObject.PartOwner.Parts)
                {
                    ThermalData thermalData = part.ThermalData with
                    {
                        CoolingEnergyToApply = 0.0
                    };
                    part.ThermalData = thermalData;
                    for (int index = 0; index < part.Modules.ValuesList.Count; ++index)
                        part.Modules.ValuesList[index].ThermalUpdate(__instance._deltaUniverseTime);
                }
                // stock code has been removed here
                __instance._simulationJobInstance.StartJobs(__instance._deltaUniverseTime);
            }
            return false;
        }
    }
}
