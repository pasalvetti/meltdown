using HarmonyLib;
using KSP.Sim.impl;
using Meltdown.Modules;

namespace Meltdown.Patches
{
    internal class ThermalComponentPatches
    {
        /**
         * Add all radiator parts in the list of coolers. They will be taken into account later on (in OnUpdate) for the dissipation.
         **/
        private static void CacheAllRadiatorsAsCoolingModules(ThermalComponent __instance)
        {
            foreach (PartComponent part in __instance.SimulationObject.PartOwner.Parts)
            {
                if (part.TryGetModule<PartComponentModule_ActiveRadiator>(out PartComponentModule_ActiveRadiator module))
                {
                    __instance._coolingModules.AddUnique<PartComponentModule_Cooler>(module);
                }
            }
        }

        /**
         * On component start, all cooling modules get cached, but not radiators. We need to add them too.
         **/
        [HarmonyPatch(typeof(ThermalComponent), nameof(ThermalComponent.OnStart))]
        [HarmonyPostfix]
        public static void OnStartPostFix(ThermalComponent __instance)
        {
            CacheAllRadiatorsAsCoolingModules(__instance);
        }

        /**
         * After a part is destroyed, RecacheCoolingModules gets called and clears our list of radiators, so we need to recache them.
         **/
        [HarmonyPatch(typeof(ThermalComponent), nameof(ThermalComponent.RecacheCoolingModules))]
        [HarmonyPostfix]
        private static void RecacheCoolingModulesPostFix(ThermalComponent __instance)
        {
            CacheAllRadiatorsAsCoolingModules(__instance);
        }

        /**
         * Return true if the part is generating heat.
         **/
        private static bool IsGeneretingHeat(PartComponent part)
        {
            if (part.TryGetModule<PartComponentModule_Thermal>(out PartComponentModule_Thermal thermalModule))
            {
                if (thermalModule._dataThermal == null) return false;
                return thermalModule._dataThermal.isHeating;
            }
            return false;
        }

        /**
         * Returns the thermal energy applied to a part.
         **/
        private static double getTotalThermalEnergyOfPart(PartComponent part)
        {
            return part.ThermalData.OtherFlux + part.ThermalData.EnvironmentFlux + part.ThermalData.ExhaustFlux + part.ThermalData.ReentryFlux + part.ThermalData.SolarFlux;
        }

        /**
         * Returns the sum of thermal energy applied to each part of the current vessel.
         **/
        private static double GetTotalThermalEnergy(ThermalComponent __instance)
        {
            double totalThermalEnergy = 0.0;
            foreach (PartComponent part in __instance.SimulationObject.PartOwner.Parts)
            {
                if (part.ThermalData.Equals(null)) continue;
                if (IsGeneretingHeat(part))
                {
                    totalThermalEnergy += (getTotalThermalEnergyOfPart(part));
                }
            }
            return totalThermalEnergy;
        }

        /**
         * The heat removing part is supposed to be done by ThermalComponentJob.FinalizeJob but for some reason this code doesn't seem to do what it is supposed to.
         * I was unable to get it to work as it's not patchable, so I'm doing this hack instead: altering the OtherFlux to take into account the heat removed by the radiators.
         * This flux should normally only contain the heat generated by the part.
         * 
         * Removes from each part of the ship the energy diffused by each radiator.
         * x100 to counteract PartComponentModule_Cooler.EnergyApplied that cannot be patched and applies a x0.01 for some reasons.
         * 
         * Prefix because it needs to run before the thermal jobs.
         **/
        [HarmonyPatch(typeof(ThermalComponent), nameof(ThermalComponent.OnUpdate))]
        [HarmonyPrefix]
        public static void OnUpdatePreFix(ThermalComponent __instance, ref double __state)
        {
            int numberOfRadiators = __instance._coolingModules.Count;
            double totalThermalEnergy = GetTotalThermalEnergy(__instance);
            __state = totalThermalEnergy;
            if (totalThermalEnergy == 0.0) return; // if no part is generating heat, there's no heat to dissipate
            foreach (PartComponent part in __instance.SimulationObject.PartOwner.Parts)
            {
                int i = numberOfRadiators;
                double energyRemoved = 0.0;
                if (IsGeneretingHeat(part))  // if the current part is generating heat, there *is* heat to dissipate.
                {
                    while (i-- > 0)
                    {
                        if (!__instance._coolingModules[i].CoolerOperational) continue; // if the radiator is retracted, move on to the next one
                        energyRemoved += (__instance._coolingModules[i].EnergyApplied * 100 * getTotalThermalEnergyOfPart(part) / totalThermalEnergy);
                    }
                }
                if (part.TryGetModule<PartComponentModule_Thermal>(out PartComponentModule_Thermal thermalModule) && thermalModule._dataThermal != null)
                {
                    thermalModule._dataThermal.energyRemoved = energyRemoved; // we store the removed energy for display on the debug window
                }
                part.ThermalData.OtherFlux -= energyRemoved; // we substract the removed energy in the other flux (dirty hack)
            }
        }
    }
}
